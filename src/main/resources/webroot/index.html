<!DOCTYPE HTML>
<html>
<head>

    <!--Let browser know website is optimized for mobile-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

    <script type="text/javascript" src="/js/zchart.js"></script>
    <script type="text/javascript">

    /*
    
    VARIABLES

    */

    // helper for mobile detection
    var ismobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);

    // client version to announce to server
    var client_version = "v1.2.3";
    var charts = []; // overview charts object
    var chartCount = 0; // chart count
    var dataLength = 40; // default graph length
    var refresh_rate = 1000/5; // call render on flipclock and charts at this rate.
    var chart_interval = null; // the normal plot interval, null = auto
    var show_legend = true;
    var logging_chance = 5; // percent chance of logging

    // if desktop, set the default chart height dynamically else fix it for mobile!
    if (!ismobile) {
        var chart_height = window.innerHeight/3 + 'px'; // the chart height, cant use % here. :/
    } else {
        var chart_height = '300px';
    }

    var min_spool_plot = 100; // minimun number of message required to make the queues graph in Overview
    var hide_counter_first_sample = true; // for "counters", hide the initial spike when refreshing view.
    var chart_type = "stackedColumn"; // the chart_type to use ( canvasjs )

    // what chart type divs exist in body, these are referenced by config
    var chart_divs = [
        "charts",
        "bigcharts",
        "smallcharts-1",
        "smallcharts-2",
        "smallcharts-3"
    ]


    // view data
    var view_data;
    // set the initial data object name to the "default" vpn.
    var active_view = "default";


    /*

    METHODS

    */


    // percent of events to log to console
    var chance_of_logging = function() {
        if (Math.floor((Math.random() * 100) + 1) < logging_chance) {
            return true;
        } else {
            return false;
        }
    }


    // notify user of events in UI
    var app_status = function(msg) {
        Materialize.toast(msg, 2500, 'z-depth-4')
    };
    var app_error = app_status;


    // queues handler
    var queues_handler = function (msg) {

        var tmpDate = new Date();
        logging = chance_of_logging;

        // var data = msg.data['rpc-reply'].rpc.show.queue.queues.queue;

        var data = data_shifter(msg.data, msg.config['data_path'], logging );

        if (logging) {
            console.log("queues_handler: ");
            console.log(msg);
        }


        // for queue in data[]
        for (var i in data){
            if (charts[2].chart.options.data[i] == undefined) {
                // console.log("queues_handler: creating initial element for " + data[i].name);
                charts[2].chart.options.data.push(
                    {
                        type: chart_type,
                        click: function(e){Materialize.toast("Fixme", 1000)},
                        dataPoints: [],
                        name: data[i].info['message-vpn'] + ":" + data[i].name
                    }
                );

            } else {

                if (Math.ceil(data[i].info['num-messages-spooled']) < min_spool_plot ) {
                    var dp = {
                        "x": tmpDate,
                        "y": 0
                    }
                    charts[2].chart.options.data[i].dataPoints.push(dp);

                } else {
                    var dp = {
                        "x": tmpDate,
                        "y": Math.ceil(data[i].info['num-messages-spooled'])
                    }
                    charts[2].chart.options.data[i].dataPoints.push(dp);

                }

            }
        }
    }


    // vpns handler
    var vpns_handler = function (msg) {

        logging = chance_of_logging;

        var tmpDate = new Date();

        var data = data_shifter(msg.data, msg.config['data_path'], logging);

        if (logging) {
            console.log("vpns_handler: ");
            console.log(msg);
        }
        
        for (var i in data){
            if (charts[0].chart.options.data[i] == undefined) {
                console.log("vpns_handler: creating initial element for " + data[i].name);
                charts[0].chart.options.data.push(
                    {
                        type: chart_type,
                        click: function(e){Materialize.toast("Click Handler", 1000)},
                        dataPoints: [],
                        name: data[i].name,
                        showInLegend: true
                    }
                );

                charts[1].chart.options.data.push(
                    {
                        type: chart_type,
                        click: function(e){Materialize.toast("Fixme", 1000)},
                        dataPoints: [],
                        name: data[i].name,
                        showInLegend: true
                    }
                );


            } else {

                // "y": data[i].stats['current-egress-rate-per-second'] + data[i].stats['current-ingress-rate-per-second']
                var dp = {
                    "x": tmpDate,
                    "y": data[i].stats['average-egress-rate-per-minute'] + data[i].stats['average-ingress-rate-per-minute']
                }
                charts[0].chart.options.data[i].dataPoints.push(dp);
                
                var tmp_val = data[i].stats['egress-discards']['total-egress-discards'] + data[i].stats['ingress-discards']['total-ingress-discards'];

                try {
                    var last_val = charts[1].chart.options.data[i].dataPoints[charts[1].chart.options.data[i].dataPoints.length-1].last_val;
                } catch(err) {
                    // if no datapoints, set last_val to current val to kill of the HUGE spike in new graph creation
                    if ( hide_counter_first_sample ) {
                        var last_val = tmp_val;
                    } else {
                        var last_val = 0;
                    }
                    
                }

                var dp = {
                    "x": tmpDate,
                    "y": tmp_val - last_val,
                    "last_val": tmp_val
                }

                charts[1].chart.options.data[i].dataPoints.push(dp);

            }
        }

    }



    // rudimentary UUID generator in javascript
    function guid() {

      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
          .toString(16)
          .substring(1);

      }

      return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
        s4() + '-' + s4() + s4() + s4();

    }


    // create a uuid 
    var uuid = guid();


    // message rate
    var target_rate;
    var current_rate;

    // states
    var popup = false; // is the popup showing
    var show_alarms = true; // initial show_alarms MUST be true, else icon will be out of sync

    // object holders
    var eb;
    var reconnector;
  
    </script>

    <!-- handlers -->
    <script src="/js/generic-view-handler.js"></script>
    <script src="/js/redundancy_handler.js"></script>
    <script src="/js/alarms_handler.js"></script>
    <script src="/js/events_handler.js"></script>

    <!-- helpers -->
    <script src="/js/helpers.js"></script>

    <!-- flipclock data handler -->
    <script src="/js/generic-stats.js"></script>

    <!-- deps -->
    <script src="/js/jquery.js"></script>
    <script src="/js/canvasjs.js"></script>
    <script src="/js/flipclock.js"></script>

    <!-- css -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/materialize/0.96.1/css/materialize.min.css">
    <link rel="stylesheet" href="/css/materialize.min.css">
    <link rel="stylesheet" href="/css/flipclock.css">
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/materialize/0.96.1/js/materialize.min.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/sockjs-client/0.3.4/sockjs.min.js"></script>

    <!-- vertx eventbus -->
    <script src="/js/vertx.js"></script>

    <!-- initial state overview -->
    <script type="text/javascript" charset="utf-8">
    $(document).ready(function(){

        CanvasJS.addColorSet("customColorSet1",
        [
            "#4684ee", "#dc3912", "#ff9900", "#008000", "#666666",
            "#4942cc", "#cb4ac5", "#d6ae00", "#336699", "#dd4477",
            "#aaaa11", "#66aa00", "#888888", "#994499", "#dd5511",
            "#22aa99", "#999999", "#705770", "#109618", "#a32929"
        ]);

        charts.push(new ZChart("Message Rate", dataLength, "bigcharts", chart_type, chart_interval));
        charts[0].chart.options.data = []; // reset chart 0 first element overriding defaults

        charts.push(new ZChart("Discard Delta", 10, "charts", chart_type, chart_interval));
        charts[1].counter = true; // set counter style for Errors
        charts[1].chart.options.data = [];

        charts.push(new ZChart("Queues >" + min_spool_plot + " msgs Spooled", dataLength, "bigcharts", chart_type), chart_interval);
        charts[2].chart.options.data = []; // reset chart 0 first element overriding defaults


        // $('#modal1').leanModal({
        //   dismissible: false, // Modal can be dismissed by clicking outside of the modal
        //   opacity: .5, // Opacity of modal background
        //   in_duration: 300, // Transition in duration
        //   out_duration: 200, // Transition out duration
        //   ready: function() { app_status('Modal Ready'); }, // Callback for Modal open
        //   complete: function() { app_status('Modal Complete'); } // Callback for Modal close
        // });


        // connect to eventbus
        initialiseEventbus = function() {

            if (!popup) {
                //$('#modal1').openModal();
                popup = true;
                // MODAL configure
                
                $('#modal1').openModal()
            }

            if (eb != null && eb.readyState() == 1) {
                clearInterval(reconnector);
                return;
            };

            app_status("Connecting...");
            eb = new vertx.EventBus("/eventbus/",
            vertxbus_ping_interval = 1000
        );

        eb.onopen = function () {
            clearInterval(reconnector);
            if (popup) {
                $('#modal1').closeModal();
                popup = false;
            }


            /*
             * Request Config from the EventBus
             *
             *
             */
            eb.send("request-config", "all", function(msg) {

                console.log("request-config: processing reply:");
                console.log(msg);

                // clean menu
                var list = document.getElementById('metrics-dropdown');
                while (list.hasChildNodes()) {   
                    list.removeChild(list.firstChild);
                }

                // the overview
                var entry = document.createElement('li');
                newlink = document.createElement('a');
                newlink.setAttribute('href', "#!");
                newlink.setAttribute('class', 'waves-effect waves-teal');
                newlink.setAttribute('onclick', "set_view('default')");
                newlink.innerHTML="Overview";
                entry.appendChild(newlink);
                list.appendChild(entry);


                // check if view_data is undefined ( reconnect condition )
                if (view_data == undefined) {
                    view_data = [];
                    for (metric in msg.metrics) {
                        console.log("registering metric config: " + msg.metrics[metric]);
                        var c = {
                             "name": msg.metrics[metric]
                         }
                         view_data[msg.metrics[metric]] = c
                    }
                }

                // get the dropdown to append content to
                var dropdown = document.getElementById('metrics-dropdown');

                // add each metric to the menu
                for (metric in msg.metrics) {

                        // if a metric is missing ( server restart with new config condition )
                        if ( view_data[msg.metrics[metric]] == undefined ) {
                            app_status("New Metric: " + msg.metrics[metric] );
                            var c = {
                             "name": msg.metrics[metric]
                            }
                            view_data[msg.metrics[metric]] = c
                        }

                        // create the button
                        var entry = document.createElement('li');
                        newlink = document.createElement('a');
                        newlink.setAttribute('href', "#!");
                        newlink.setAttribute('class', 'waves-effect waves-teal');
                        newlink.setAttribute('onclick', "set_view('" + msg.metrics[metric] + "')");
                        newlink.innerHTML=msg.metrics[metric];
                        entry.appendChild(newlink);

                        // append to dropdown
                        dropdown.appendChild(entry);

                        console.log("Request Config: " + msg.metrics[metric]);
                        eb.send("request-config", msg.metrics[metric], function(reply) {
                            console.log("Registering Handler: " + reply.topic);
                            console.log(reply);
                            if (reply.config.handler == undefined) {
                                eb.registerHandler(reply.topic, view_handler);
                            } else {
                                eb.registerHandler(reply.topic, window[reply.config.handler]);
                            }
                        })
                    }


                    
                    
                
            });

            // tell the user what's what
            app_status("Registering Handlers");

            // allows the server to send special commands to THIS client
            eb.registerHandler(uuid, function(msg) {
                console.log("uuid message");
                console.log(msg);
                if (msg.action == "reload") {
                    console.log("server demands I reload");
                    location.reload();
                } else if (msg.action == "broadcast") {
                    app_status(msg.data);
                }
            });

            // announce client to the server
            var t = {
                    "version": client_version,
                    "uuid": uuid
                }
                eb.send("newclient", t);

            // periodic pings to server
            setInterval(function() {
                var t = {
                    "version": client_version,
                    "uuid": uuid
                }
                eb.send("client-ping", t);
            }, 10000);


            // // generic stats handler is the flipclock
            // eb.registerHandler("stats", generic_stats);

            // // queue stats handler
            // eb.registerHandler("queues", queues_handler);

            // // handler for vpns
            // eb.registerHandler("vpns", vpns_handler);

            // eb.registerHandler("events", view_handler);

            // eb.registerHandler("redundancy", redundancy_handler);

            // eb.registerHandler("alarm", alarms_handler);

            // eb.registerHandler("memory", view_handler)

            // if this is a reconnect, call set_view to resubscribe, else just ignore it.
            if (active_view != "default") {

                set_view(active_view);
            }

        };

        eb.onclose = function () {
            app_status("Disconnected");
            clearInterval(reconnector);
            reconnector = setInterval(initialiseEventbus, 5000);
            var toggle = true;

        }
        
        // make flipclock smaller on mobile
        if (ismobile) {
            document.getElementById("flipclock").style.zoom = 0.5;
            document.getElementById("flipclock").style.MozTransition = "transform: scale(0.5)";
            toggle_legend();
        }

    }


    initialiseEventbus();


});
             
</script>

</head>
<body>
<main>
<div class="navbar-fixed">
    <nav>
        <div class="nav-wrapper blue">

            <a href="#" id="app_title" class="hide-on-small-only brand-logo center">Solace Monitor</a>

            <ul id="nav-fixed" class="left blue">
                <!-- <i class="left mdi-file-cloud-done"></i> -->

                <li><a class='dropdown-button' data-constrainwidth="false"  data-beloworigin="true" href='#' data-activates='metrics-dropdown'><i class="mdi-navigation-menu" data-position="bottom" data-delay="50" data-tooltip="Select a Dashboard"></i></a></li>            

                <!-- chart Type  -->
                <li><a class='dropdown-button' data-constrainwidth="false" data-beloworigin="true" href='#' data-activates='chart-type-dropdown'><i class="mdi-editor-insert-chart"></i></a></li>

                <li><a class='button' onclick=toggle_alarms()><i id="nav_alarms" class="mdi-action-alarm-on"></i></a></li>


                <!-- menu vpn-->
                <ul id='metrics-dropdown' class='dropdown-content z-depth-2'>
                    <li><a href="#!" class='waves-effect waves-teal' onclick=set_view("default")>Overview</a></li>
                </ul>


                <ul id='chart-type-dropdown' class='dropdown-content z-depth-2'>
                    <li><a href="#!" class='waves-effect waves-teal' onclick=toggle_legend()>Legend</a></li>
                     <li class="divider"></li>
                    <li><a href="#!" class='waves-effect waves-teal' onclick=toggle_chart_type('stackedArea')>Area</a></li>
                    <li><a href="#!" class='waves-effect waves-teal' onclick=toggle_chart_type('stackedColumn')>Column</a></li>
                </ul>





            </ul>
        </div>
    </nav>
</div>

<div style="width: 100%">
    <div class="valign-wrapper center">

        <div class="row" style="width: 100%">
            <div class="valign center"><!--<h3 class="center-align">Solace Messages Since Go-Live</h3>-->
                <div id="flipclock" class="h1z1-clock"></div>
            </div>
            <div class="row">
                <div id="bigcharts" class="bigcharts col s12 l8 zchartContainer valign center"></div>
                <div id="charts" class="col s12 l4 zchartContainer valign center"></div>
            </div>
            <div class="row">
                <div id="smallcharts-1" class="col s12 l4 zchartContainer valign center"></div>
                <div id="smallcharts-2" class="col s12 l4 zchartContainer valign center"></div>
                <div id="smallcharts-3" class="col s12 l4 zchartContainer valign center"></div>
            </row>
        </div>

                
    </div> 


    <!-- Modal Structure -->
<div id="modal1" class="modal">

    <!-- <canvas id="canvas"> -->
        <div class="modal-content">
            <h4>Connection Lost</h4>
            <p>reconnecting...</p>
        </div>
        <div class="progress">
            <div class="indeterminate blue"></div>
        </div>
    <!-- </canvas> -->
</div>

<!-- bottom-sheet  -->
<div id="alarmmodal" class="modal red accent-4 z-depth-4">
    <h4>Alarms</h4>
    <ul id="alarmscollection" class="collection"></ul>
</div>

</div>



</div>


</main>



<footer class="sticky-footer blue hide-on-small-only">
    <div class="footer-copyright blue">
        <div class="container blue">
            by Kegan Holtzhausen
            <a class="grey-text text-lighten-4 right" href="https://github.com/unixunion/solace-dashboards">Source</a>
        </div>
    </div>
</footer>






<script type="text/javascript">
 
    // flipclock stuff
    var clock = $('.h1z1-clock').FlipClock(target_rate, {
        clockFace: 'Counter'
    });

    setTimeout(function() {
        setInterval(function() {
      
            if (current_rate < target_rate ) {
                current_rate = Math.ceil(current_rate + ((target_rate-current_rate)/refresh_rate));
            } else {
                current_rate = target_rate;
            }
      
      
            clock.setCounter(Math.ceil(current_rate/1000) + "K")
        }, refresh_rate);
    });




  
</script>



</body>
</html>