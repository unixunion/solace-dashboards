<!DOCTYPE HTML>
<html>
<head>

    <!--Let browser know website is optimized for mobile-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

    <script type="text/javascript" src="/js/zchart.js"></script>
    <script type="text/javascript">

    var client_version = "v1.2.1";

    // the current view objects
    var charts = [];
    var chartCount = 0; // chart c
    var dataLength = 40; // default graph length
    var refresh_rate = 1000/5;
    var chart_interval = 5;

    var min_spool_plot = 100;
    var hide_counter_first_sample = true;
    var show_alarms = true;

    // message rate
    var target_rate;
    var current_rate;

    // is the popup showing
    var popup = false;

    // default chart type
    var chart_type = "stackedColumn";

    // public var for eventbus and reconnector timer
    var eb;
    var reconnector;
    
    // what chart type divs exist in BODY
    var chart_divs = [
        "charts",
        "bigcharts",
        "smallcharts-1",
        "smallcharts-2",
        "smallcharts-3"
    ]


    // percent of events to log to console
    var chance_of_logging = function() {
        if (Math.floor((Math.random() * 100) + 1) < 30) {
            return true;
        } else {
            return false;
        }
    }


    // notify user of events in UI
    var app_status = function(msg) {
        Materialize.toast(msg, 2500, 'z-depth-4')
    };

    var app_error = app_status;


    // queues handler
    var queues_handler = function (msg) {

        var tmpDate = new Date();
        logging = chance_of_logging;

        var data = msg.data['rpc-reply'].rpc.show.queue.queues.queue;

        // 30 % change of logging
        if (logging) {
            console.log("queues");
            console.log(msg);
        }

        for (var i in data){
            if (charts[2].chart.options.data[i] == undefined) {
                //console.log("creating initial element for " + data[i].name);
                charts[2].chart.options.data.push(
                    {
                        type: chart_type,
                        dataPoints: [],
                        name: data[i].name
                    }
                );

            } else {

                if (Math.ceil(data[i].info['num-messages-spooled']) < min_spool_plot ) {
                    var dp = {
                        "x": tmpDate,
                        "y": 0
                    }
                    charts[2].chart.options.data[i].dataPoints.push(dp);

                } else {

                    var dp = {
                        "x": tmpDate,
                        "y": Math.ceil(data[i].info['num-messages-spooled'])
                    }
                    charts[2].chart.options.data[i].dataPoints.push(dp);

                }

            }
        }


    }


    // vpns handler
    var vpns_handler = function (msg) {

        logging = chance_of_logging;

        var tmpDate = new Date();

        var data = data_shifter(msg.data, msg.config['data_path'], logging);

        if (logging) {
            console.log("vpns_handler: ");
            console.log(msg);
        }
        
        for (var i in data){
            if (charts[0].chart.options.data[i] == undefined) {
                console.log("creating initial element for " + data[i].name);
                charts[0].chart.options.data.push(
                    {
                        type: chart_type,
                        dataPoints: [],
                        name: data[i].name,
                        showInLegend: true
                    }
                );

                charts[1].chart.options.data.push(
                    {
                        type: chart_type,
                        dataPoints: [],
                        name: data[i].name,
                        showInLegend: true
                    }
                );


            } else {

                // "y": data[i].stats['current-egress-rate-per-second'] + data[i].stats['current-ingress-rate-per-second']
                var dp = {
                    "x": tmpDate,
                    "y": data[i].stats['average-egress-rate-per-minute'] + data[i].stats['average-ingress-rate-per-minute']
                }
                charts[0].chart.options.data[i].dataPoints.push(dp);
                
                var tmp_val = data[i].stats['egress-discards']['total-egress-discards'] + data[i].stats['ingress-discards']['total-ingress-discards'];

                try {
                    var last_val = charts[1].chart.options.data[i].dataPoints[charts[1].chart.options.data[i].dataPoints.length-1].last_val;
                } catch(err) {
                    // if no datapoints, set last_val to current val to kill of the HUGE spike in new graph creation
                    if ( hide_counter_first_sample ) {
                        var last_val = tmp_val;
                    } else {
                        var last_val = 0;
                    }
                    
                }

                var dp = {
                    "x": tmpDate,
                    "y": tmp_val - last_val,
                    "last_val": tmp_val
                }

                charts[1].chart.options.data[i].dataPoints.push(dp);

            }
        }

    }



    // rudimentary UUID generator in javascript
    function guid() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
          .toString(16)
          .substring(1);
      }
      return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
        s4() + '-' + s4() + s4() + s4();
    }

    // create a uuid 
    var uuid = guid();

    // helper for mobile detection
    var ismobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);

  
    </script>

    <!-- vpn stats handler -->
    <script src="/js/vpn-stats-handler.js"></script>

    <!-- helpers -->
    <script src="/js/helpers.js"></script>
    <script src="/js/generic-stats.js"></script>

    <script src="/js/jquery.js"></script>
    <script src="/js/canvasjs.js"></script>
    <script src="/js/flipclock.js"></script>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/materialize/0.96.1/css/materialize.min.css">
    <link rel="stylesheet" href="/css/materialize.min.css">
    <link rel="stylesheet" href="/css/flipclock.css">
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/materialize/0.96.1/js/materialize.min.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/sockjs-client/0.3.4/sockjs.min.js"></script>
    <script src="/js/vertx.js"></script>

    <script type="text/javascript" charset="utf-8">
    $(document).ready(function(){

        CanvasJS.addColorSet("customColorSet1",
        [
            "#4684ee", "#dc3912", "#ff9900", "#008000", "#666666",
            "#4942cc", "#cb4ac5", "#d6ae00", "#336699", "#dd4477",
            "#aaaa11", "#66aa00", "#888888", "#994499", "#dd5511",
            "#22aa99", "#999999", "#705770", "#109618", "#a32929"
        ]);

        charts.push(new ZChart("Message Rate", dataLength, "bigcharts", chart_type, chart_interval));
        charts[0].chart.options.data = []; // reset chart 0 first element overriding defaults

        charts.push(new ZChart("Discard Delta", 10, "charts", chart_type, chart_interval));
        charts[1].counter = true; // set counter style for Errors
        charts[1].chart.options.data = [];

        charts.push(new ZChart("Queues >" + min_spool_plot + " msgs Spooled", dataLength, "bigcharts", chart_type), chart_interval);
        charts[2].chart.options.data = []; // reset chart 0 first element overriding defaults


        // $('#modal1').leanModal({
        //   dismissible: false, // Modal can be dismissed by clicking outside of the modal
        //   opacity: .5, // Opacity of modal background
        //   in_duration: 300, // Transition in duration
        //   out_duration: 200, // Transition out duration
        //   ready: function() { app_status('Modal Ready'); }, // Callback for Modal open
        //   complete: function() { app_status('Modal Complete'); } // Callback for Modal close
        // });


        // connect to eventbus
        initialiseEventbus = function() {

            if (!popup) {
                //$('#modal1').openModal();
                popup = true;
                // MODAL configure
                
                $('#modal1').openModal()
            }

            if (eb != null && eb.readyState() == 1) {
                clearInterval(reconnector);
                return;
            };

            app_status("Connecting...");
            eb = new vertx.EventBus("/eventbus/",
            vertxbus_ping_interval = 1000
        );

        eb.onopen = function () {
            clearInterval(reconnector);
            if (popup) {
                $('#modal1').closeModal();
                popup = false;
            }


            // // request list of VPN, and prime the vpn_charts object
            // eb.send("request-metrics", "list-vpns", function(msg) {
            //     //console.log("list-vpns:");
            //     //console.log(msg);

            //     // if vpn_data is undefined, populate it
            //     if (vpn_data == undefined) {
            //         vpn_data = [];
            //         console.log("init list-vpns reply:");
            //         var data = msg['rpc-reply'].rpc.show['message-vpn'].vpn;
            //         console.log(data);
            //         for (var i in data) {
            //             var c = {
            //                 "name": data[i].name,
            //             }
            //             console.log("registering vpn_data key: " + data[i].name);
            //             vpn_data[data[i].name] = c
                        
            //             // register UI
            //             var node = document.getElementById('vpns');
            //             var entry = document.createElement('li');
                        
            //             newlink = document.createElement('a');
            //             newlink.setAttribute('href', "#!");
            //             newlink.setAttribute('class', 'waves-effect waves-teal');
            //             newlink.setAttribute('onclick', "set_view_vpn('" +data[i].name + "')");
            //             newlink.innerHTML=data[i].name;
            //             entry.appendChild(newlink);
            //             node.appendChild(entry);
                        
            //         }
            //     }
            // });

            
            eb.send("request-config", "please", function(msg) {

                // clean menu
                var list = document.getElementById('metrics-dropdown');
                while (list.hasChildNodes()) {   
                    list.removeChild(list.firstChild);
                }

                // the overview
                var entry = document.createElement('li');
                newlink = document.createElement('a');
                newlink.setAttribute('href', "#!");
                newlink.setAttribute('class', 'waves-effect waves-teal');
                newlink.setAttribute('onclick', "location.reload()");
                newlink.innerHTML="Overview";
                entry.appendChild(newlink);
                list.appendChild(entry);

                // check if vpn_data is undefined ( reconnect condition )
                if (vpn_data == undefined) {
                    vpn_data = [];
                    for (metric in msg.metrics) {
                        console.log("registering metric config: " + msg.metrics[metric]);
                        var c = {
                             "name": msg.metrics[metric]
                         }
                         vpn_data[msg.metrics[metric]] = c
                    }
                }

                for (metric in msg.metrics) {

                        // if a metric is missing
                        if ( vpn_data[msg.metrics[metric]] == undefined ) {
                            app_status("Registering Metric: " + msg.metrics[metric] );
                            var c = {
                             "name": msg.metrics[metric]
                            }
                            vpn_data[msg.metrics[metric]] = c
                        }


                        var node = document.getElementById('metrics-dropdown');
                        var entry = document.createElement('li');
                        
                        newlink = document.createElement('a');
                        newlink.setAttribute('href', "#!");
                        newlink.setAttribute('class', 'waves-effect waves-teal');
                        newlink.setAttribute('onclick', "set_view_vpn('" + msg.metrics[metric] + "')");
                        newlink.innerHTML=msg.metrics[metric];
                        entry.appendChild(newlink);
                        node.appendChild(entry);
                    }
                
            });

            // tell the user whats what
            app_status("Registering Handlers");

            // allows the server to send special commands to THIS client
            eb.registerHandler(uuid, function(msg) {
                console.log("uuid message");
                console.log(msg);
                if (msg.action == "reload") {
                    console.log("server demands I reload");
                    location.reload();
                } else if (msg.action == "broadcast") {
                    app_status(msg.data);
                }
            });

            // announce client to the server
            var t = {
                "version": client_version,
                "uuid": uuid
            }
            eb.send("newclient", t);

            // generic stats handler is the flipclock
            eb.registerHandler("stats", generic_stats);

            // queue stats handler
            eb.registerHandler("queues", queues_handler);

            // handler for vpns
            eb.registerHandler("vpns", vpns_handler);

            eb.registerHandler("alarm", function (msg) {
                var d = data_shifter(msg.data, msg.config['data_path'], true)

                var node = document.getElementById('alarmscollection');
                while (node.hasChildNodes()) {   
                        node.removeChild(node.firstChild);
                }

                if ( d != undefined ) {

                    var found_alarm = false;

                    for (alarm in d) {

                        var a = document.createElement('li');
                        a.setAttribute('class', "collection-item avatar");

                        var icon = document.createElement('i')
                        icon.setAttribute('class', 'mdi-alert-warning circle');
                        a.appendChild(icon);

                        var title = document.createElement('span');
                        title.setAttribute('class', 'title');
                        title.innerHTML = d[alarm]['message'];
                        a.appendChild(title);

                        for (k in d[alarm]) {
                            if (k != "message") {
                                var desc = document.createElement('p');
                                desc.innerHTML = k + ":" + d[alarm][k];
                                a.appendChild(desc);
                                node.appendChild(a);
                                found_alarm = true;
                            }
                        }
                                       
                    }

                    if (found_alarm && show_alarms) {
                        $('#alarmmodal').openModal()
                    } else {
                        console.log("thought I did, but I didnt find a alarm");
                    }

                }




            })

            eb.registerHandler("memory", function (msg) {
                console.log("memory");
                console.log(msg);
            })

            // if this is a reconnect, call set_view_vpn to resubscribe, else just ignore it.
            if (vpn_data_active_topic != "default") {

                set_view_vpn(vpn_data_active_topic);
            }

        };

        eb.onclose = function () {
            app_status("Disconnected");
            clearInterval(reconnector);
            reconnector = setInterval(initialiseEventbus, 5000);
            var toggle = true;

        }
        
        // make flipclock smaller on mobile
        if (ismobile) {
            document.getElementById("flipclock").style.zoom = 0.5;
            document.getElementById("flipclock").style.MozTransition = "transform: scale(0.5)";
            toggle_legend();
        }

    }


    initialiseEventbus();


});
             
</script>

</head>
<body>

<div class="navbar-fixed">
    <nav>
        <div class="nav-wrapper blue">

            <a href="#" id="app_title" class="hide-on-small-only brand-logo center">Solace Monitor</a>

            <ul id="nav-fixed" class="left blue">
                <i class="left mdi-file-cloud-done"></i>

                <li><a class='dropdown-button' data-constrainwidth="false"  data-beloworigin="true" href='#' data-activates='metrics-dropdown'><i class="mdi-action-assessment" data-position="bottom" data-delay="50" data-tooltip="Select a Dashboard"></i></a></li>

                <!-- Settings  -->
                <li><a class='dropdown-button' data-constrainwidth="false" data-beloworigin="true" href='#' data-activates='settings-dropdown'><i class="mdi-action-settings-applications" data-position="bottom" data-delay="50" data-tooltip="Settings"></i></a></li>

                <!-- menu vpn-->
                <ul id='metrics-dropdown' class='dropdown-content z-depth-2'>
                    <li><a href="#!" class='waves-effect waves-teal' onclick=location.reload()>Overview</a></li>
                </ul>

                <!-- menu settings -->
                <ul id='settings-dropdown' class='dropdown-content z-depth-2'>
                    <li><a href="#!" class='waves-effect waves-teal' onclick=toggle_legend()>Legend</a></li>
                    <li><a href="#!" class='waves-effect waves-teal' onclick=show_alarms=!show_alarms>Mute Alarms</a></li>
                </ul>


            </ul>
        </div>
    </nav>
</div>

<div style="height: 100%; width: 100%">
    <div class="valign-wrapper center">

        <div class="row" style="width: 100%">
            <div class="valign center"><!--<h3 class="center-align">Solace Messages Since Go-Live</h3>-->
                <div id="flipclock" class="h1z1-clock"></div>
            </div>
            <div class="row">
                <div id="bigcharts" class="bigcharts col s12 l8 zchartContainer valign center"></div>
                <div id="charts" class="col s12 l4 zchartContainer valign center"></div>
            </div>
            <div class="row">
                <div id="smallcharts-1" class="col s12 l4 zchartContainer valign center"></div>
                <div id="smallcharts-2" class="col s12 l4 zchartContainer valign center"></div>
                <div id="smallcharts-3" class="col s12 l4 zchartContainer valign center"></div>
            </row>
        </div>
    </div>

    <!-- Modal Structure -->
    <div id="modal1" class="modal">

        <!-- <canvas id="canvas"> -->
            <div class="modal-content">
                <h4>Connection Lost</h4>
                <p>reconnecting...</p>
            </div>
            <div class="progress">
                <div class="indeterminate"></div>
            </div>
        <!-- </canvas> -->
    </div>

    <div id="alarmmodal" class="modal bottom-sheet">
    <h4>Alarms</h4>
    <ul id="alarmscollection" class="collection">

    </ul>
            
    </div> 


</div>

    <footer class="page-footer blue hide-on-small-only">
        <div class="footer-copyright blue">
            <div class="container blue">
                by Kegan Holtzhausen
                <a class="grey-text text-lighten-4 right" href="https://github.com/unixunion/solace-dashboards">Source</a>
            </div>
        </div>
    </footer>

<script type="text/javascript">
 
    // flipclock stuff
    var clock = $('.h1z1-clock').FlipClock(target_rate, {
        clockFace: 'Counter'
    });

    setTimeout(function() {
        setInterval(function() {
      
            if (current_rate < target_rate ) {
                current_rate = Math.ceil(current_rate + ((target_rate-current_rate)/refresh_rate));
            } else {
                current_rate = target_rate;
            }
      
      
            clock.setCounter(Math.ceil(current_rate/1000) + "K")
        }, refresh_rate);
    });




  
</script>



</body>
</html>