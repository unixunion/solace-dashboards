<!DOCTYPE HTML>
<html>
<head>

    <!--Let browser know website is optimized for mobile-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

    <script type="text/javascript" src="/js/zchart.js"></script>
    <script type="text/javascript">

    var client_version = "v1.1.3";

    // a place to store VPN objects
    var vpn_data;
    var vpn_data_length = 40;
    var vpn_data_active_topic = "default";

    // the current view objects
    var charts = [];
    var chartCount = 0; // chart c
    var dataLength = 40; // default graph length
    var refresh_rate = 1000/5;

    var min_spool_plot = 5;
    var hide_counter_first_sample = false;

    // message rate
    var target_rate;
    var current_rate;

    // is the popup showing
    var popup = false;

    // lock the render / array shifting until data handlers
    // add topic.name and boolean for each monitored endpoint in vertx
    // not used at the moment since, its probably bad, m'kay...
    var lock_render = {};

    // chart type
    var chart_type = "stackedColumn";

    // public var for eventbus and reconnector timer
    var eb;
    var reconnector;
    
    // what chart type divs exist in BODY
    var chart_divs = [
        "charts",
        "bigcharts",
        "smallcharts-1",
        "smallcharts-2",
        "smallcharts-3",
        "smallcharts-4"
    ]


    // percent of events to log to console
    var chance_of_logging = function() {
        if (Math.floor((Math.random() * 100) + 1) < 30) {
            return true;
        } else {
            return false;
        }
    }


    // notify user of events in UI
    var app_status = function(msg) {
        Materialize.toast(msg, 2500, 'z-depth-4')
    };


    // handls show vpn-name X stats, topic name is the key to value in vpn_data
    var vpn_stats_handler = function(msg) {
        
        lock_render[msg.topic] = true;
        // on chance of logging, set to true
        var logging = chance_of_logging();
        var tmpDate = new Date();
        
        if (logging) {
            console.log("vpn_data msg");
            console.log(msg);
        }

        var path_hint;
        // get the pathing hint from msg.config
        try {
            path_hint = msg.config['data_path'].split(".");
            console.log("vpn_stats_handler path_hint: " + path_hint);
        } catch (err) {
            console.log("no data_path hint for " + msg.topic);
        }

        var data = msg.data
        // read the data from the message
        for (var word in path_hint) {
            data = data[path_hint[word]]
        }

        console.log("shifted data");
        console.log(data);


        //var data = msg.data['rpc-reply'].rpc.show['message-vpn'].vpn.stats;

        // read the config out of the message
        var config = msg.config['view_format'];
        
        if (logging) {
            console.log("vpn_data config");
            console.log(config);
        }
        
        // if this msg.topic has no charts, create a array for them
        if (vpn_data[msg.topic].charts == undefined) {
            vpn_data[msg.topic].charts = [];
        }
        
        for (var emit_config in config) {
            
            var metric_list = config[emit_config].show;
            
            if (vpn_data[msg.topic].charts[emit_config] == undefined) {

                // always log creations
                console.log("create chart config: " + emit_config);
                console.log(config[emit_config]);
                

                var div_name = (config[emit_config].div === undefined) ? "bigcharts" : config[emit_config].div;
                var chart_type = (config[emit_config].chart_type == undefined) ? "stackedColumn" : config[emit_config].chart_type;
                var chart_length = (config[emit_config].chart_length == undefined) ? 10 : config[emit_config].chart_length;
                var counter = (config[emit_config].counter == undefined) ? false : config[emit_config].counter;
                var data_path = config[emit_config].data_path;
                var metric_list = config[emit_config].show;             
                
                
                vpn_data[msg.topic].charts[emit_config] = new ZChart(emit_config, chart_length, div_name, chart_type);
                vpn_data[msg.topic].charts[emit_config].counter = counter;
                
                // if multiple values, create multiple datapoint objects
                vpn_data[msg.topic].charts[emit_config].chart.options.data = [];
                
                for (var e in metric_list ) {
                    vpn_data[msg.topic].charts[emit_config].chart.options.data.push(
                        {
                            type: chart_type,
                            dataPoints: [],
                            name: config[emit_config].show[e],
                            showInLegend: !ismobile,
                        }
                    );
                }
                
            }
            
            for (var e in metric_list ){
                // console.log("update value for: " + config[emit_config].map.show.list[e]);
                //
                // console.log("e: " + e);
                //
                // console.log("raw data");
                // console.log(data);
                //
                // console.log("data " + data[config[emit_config].map.show.list[e]]);
                
                var tmp_results = 0;
                
                // ADD_TOGETHER if you really want it... gonna remove this I think.
                if ( config[emit_config].modifier != undefined ) {
                    if ( config[emit_config].modifier == "add_together" ) {
                        tmp_results = tmp_results + data[metric_list[e]];
                    }


                    
                // DEFAULT
                } else {

                    var data_before_decend = data;

                    if (data_path == undefined){
                        tmp_results = data[metric_list[e]];
                    } else {
                        console.log("hunting: " + metric_list[e]);
                        console.log("dump data: ");
                        console.log(data);
                        // traverse into the data path.
                        var path_hint = data_path.split(".");
                        console.log("path_hint: " + path_hint);
                        for (var word in path_hint) {
                            console.log("descending into " + path_hint[word]);
                            console.log(data);
                            data = data[path_hint[word]];
                        }
                        console.log("final data: ");
                        console.log(data);
                        try {
                            tmp_results = data[metric_list[e]];
                        } catch (err) {
                            app_status("Error getting key " + metric_list[e]);
                        }
                        
                    }
                }
                
            
                // CHECK COUNTER, DELTA
                if (vpn_data[msg.topic].charts[emit_config].counter) {
                   
                    var chart = vpn_data[msg.topic].charts[emit_config].chart.options.data[e].dataPoints;
                    
                    try {
                        var last_val = chart[chart.length-1].last_val;
                    } catch(err) {
                        console.log("no history, setting to current value for delta");
                        
                        if (show_counters_as_delta) {
                            var last_val = tmp_results;
                        } else {
                            // If you want to see the initial SPIKE
                            var last_val = 0;
                        }
                        
                    }
                } else {
                    var last_val = 0;
                }

                // push custom
                var dp = {
                    "x": tmpDate,
                    "y": tmp_results - last_val,
                    "last_val": tmp_results
                }
                vpn_data[msg.topic].charts[emit_config].chart.options.data[e].dataPoints.push(dp);
                
                data = data_before_decend;
            }
            
        }

        lock_render[msg.topic] = false;
      
        
    }

    // set the view
    var set_view_vpn = function(msg) {

        lock_render[msg.topic] = true;

        if (vpn_data_active_topic != msg) {
            app_status("Changing View to " + msg);
            
            // clear all charts out
            for (cd in chart_divs) {
                var list = document.getElementById(chart_divs[cd]);
                while (list.hasChildNodes()) {   
                    list.removeChild(list.firstChild);
                }
            }

            try {
                vpn_data[vpn_data_active_topic].charts = {}
            } catch (err) {
                console.log("no object " + vpn_data_active_topic + " in vpn_data");
            }
            chartCount = 0;
            
            // unregister and register the new topic
            eb.unregisterHandler(vpn_data_active_topic, vpn_stats_handler);
            eb.registerHandler(msg, vpn_stats_handler);
            vpn_data_active_topic = msg;

            // set the VPN name in the NavBar
            document.getElementById("app_title").innerHTML = msg;
            
            // shrink the counter
            try {
                document.getElementById("flipclock").style.zoom = 0.5;
                document.getElementById("flipclock").style.MozTransition = "transform: scale(0.5)";
            } catch (err) {
                console.log("unable to resize flipclock");
            }
            
            app_status("Please Standby");
            
        } else {
            app_status("you're already there, resubscribing");
            eb.unregisterHandler(vpn_data_active_topic, vpn_stats_handler);
            eb.registerHandler(msg, vpn_stats_handler);
        }

        lock_render[msg.topic] = false;
        
    }


    // stats handler for basic rate information for the flipclock
    var stats_handler = function (msg) {

        lock_render[msg.topic] = true;

        if (Math.floor((Math.random() * 100) + 1) < chance_of_logging) {
            console.log("stats");
            console.log(msg);
        }

        // the main counter
        var data = msg.data['rpc-reply'].rpc.show.stats.client.global.stats;
        target_rate = data['total-client-messages-received'] + data['total-client-messages-sent'];

        lock_render[msg.topic] = false;

    }



    // queues handler
    var queues_handler = function (msg) {

        lock_render[msg.topic] = true;

        var tmpDate = new Date();

        var data = msg.data['rpc-reply'].rpc.show.queue.queues.queue;

        // 30 % change of logging
        if (Math.floor((Math.random() * 100) + 1) < chance_of_logging) {
            console.log("queues");
            console.log(msg);
        }

        for (var i in data){
            if (charts[2].chart.options.data[i] == undefined) {
                //console.log("creating initial element for " + data[i].name);
                charts[2].chart.options.data.push(
                    {
                        type: "stackedColumn",
                        dataPoints: [],
                        name: data[i].name
                    }
                );

            } else {

                if (Math.ceil(data[i].info['num-messages-spooled']) < min_spool_plot ) {
                    // We dont care below 300, so supress it by setting 0
                    var dp = {
                        "x": tmpDate,
                        "y": 0
                    }
                    charts[2].chart.options.data[i].dataPoints.push(dp);

                } else {

                    var dp = {
                        "x": tmpDate,
                        "y": Math.ceil(data[i].info['num-messages-spooled'])
                    }
                    charts[2].chart.options.data[i].dataPoints.push(dp);

                }

            }
        }

        lock_render[msg.topic] = false;

    }


    // vpns handler
    var vpns_handler = function (msg) {

        lock_render[msg.topic] = true;
        var tmpDate = new Date();

        var data = msg.data['rpc-reply'].rpc.show['message-vpn'].vpn;

        // 30 % change of logging
        if (Math.floor((Math.random() * 100) + 1) < chance_of_logging) {
            console.log("vpns");
            console.log(msg);
        }
        
        for (var i in data){
            if (charts[0].chart.options.data[i] == undefined) {
                console.log("creating initial element for " + data[i].name);
                charts[0].chart.options.data.push(
                    {
                        type: chart_type,
                        dataPoints: [],
                        name: data[i].name,
                        showInLegend: !ismobile,
                    }
                );

                charts[1].chart.options.data.push(
                    {
                        type: chart_type,
                        dataPoints: [],
                        name: data[i].name,
                    }
                );


            } else {

                var dp = {
                    "x": tmpDate,
                    "y": data[i].stats['current-egress-rate-per-second'] + data[i].stats['current-ingress-rate-per-second']
                }
                charts[0].chart.options.data[i].dataPoints.push(dp);
                
                var tmp_val = data[i].stats['egress-discards']['total-egress-discards'] + data[i].stats['ingress-discards']['total-ingress-discards'];

                try {
                    var last_val = charts[1].chart.options.data[i].dataPoints[charts[1].chart.options.data[i].dataPoints.length-1].last_val;
                } catch(err) {
                    // if no datapoints, set last_val to current val to kill of the HUGE spike in new graph creation
                    if ( show_counters_as_delta ) {
                        var last_val = tmp_val;
                    } else {
                        var last_val = 0;
                    }
                    
                }

                var dp = {
                    "x": tmpDate,
                    "y": tmp_val - last_val,
                    "last_val": tmp_val
                }

                charts[1].chart.options.data[i].dataPoints.push(dp);

            }
        }

        lock_render[msg.topic] = false;
    }



    // rudimentary UUID generator in javascript
    function guid() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
          .toString(16)
          .substring(1);
      }
      return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
        s4() + '-' + s4() + s4() + s4();
    }

    // create a uuid 
    var uuid = guid();

    // helper for mobile detection
    var ismobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);


  
    </script>

    <script src="/js/jquery.js"></script>
    <script src="/js/canvasjs.js"></script>
    <script src="/js/flipclock.js"></script>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/materialize/0.96.1/css/materialize.min.css">
    <link rel="stylesheet" href="/css/materialize.min.css">
    <link rel="stylesheet" href="/css/flipclock.css">
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/materialize/0.96.1/js/materialize.min.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/sockjs-client/0.3.4/sockjs.min.js"></script>
    <script src="/js/vertx.js"></script>

    <script type="text/javascript" charset="utf-8">
    $(document).ready(function(){

        CanvasJS.addColorSet("customColorSet1",
        [
            "#4684ee", "#dc3912", "#ff9900", "#008000", "#666666",
            "#4942cc", "#cb4ac5", "#d6ae00", "#336699", "#dd4477",
            "#aaaa11", "#66aa00", "#888888", "#994499", "#dd5511",
            "#22aa99", "#999999", "#705770", "#109618", "#a32929"
        ]);

        charts.push(new ZChart("Message Rate", dataLength, "bigcharts", "area"));
        charts[0].chart.options.data = []; // reset chart 0 first element overriding defaults

        charts.push(new ZChart("Discard Delta", 10, "charts", "stackedColumn"));
        charts[1].counter = true; // set counter style for Errors
        charts[1].chart.options.data = [];

        charts.push(new ZChart("Notable Queues", dataLength, "bigcharts", "stackedColumn"));
        charts[2].chart.options.data = []; // reset chart 0 first element overriding defaults


        // connect to eventbus
        initialiseEventbus = function() {

            if (!popup) {
                $('#modal1').openModal();
                popup = true;
            }

            if (eb != null && eb.readyState() == 1) {
                clearInterval(reconnector);
                return;
            };

            app_status("Connecting...");
            eb = new vertx.EventBus("/eventbus/",
            vertxbus_ping_interval = 1000
        );

        eb.onopen = function () {
            clearInterval(reconnector);
            if (popup) {
                $('#modal1').closeModal();
                popup = false;
            }
            
            // subscribe to broadcast messages from the server
            //console.log("registering handler: " + uuid);
            //eb.registerHandler(uuid, function (msg) {
            //    app_status(msg);
            //});

            // request list of VPN, and prime the vpn_charts object
            eb.send("request-metrics", "list-vpns", function(msg) {
                //console.log("list-vpns:");
                //console.log(msg);

                // if vpn_data is undefined, populate it
                if (vpn_data == undefined) {
                    vpn_data = [];
                    console.log("init list-vpns reply:");
                    var data = msg['rpc-reply'].rpc.show['message-vpn'].vpn;
                    console.log(data);
                    for (var i in data) {
                        var c = {
                            "name": data[i].name,
                        }
                        console.log("registering vpn_data key: " + data[i].name);
                        vpn_data[data[i].name] = c
                        
                        // register UI
                        var node = document.getElementById('vpns');
                        var entry = document.createElement('li');
                        
                        newlink = document.createElement('a');
                        newlink.setAttribute('href', "#!");
                        newlink.setAttribute('class', 'waves-effect waves-teal');
                        newlink.setAttribute('onclick', "set_view_vpn('" +data[i].name + "')");
                        newlink.innerHTML=data[i].name;
                        entry.appendChild(newlink);
                        node.appendChild(entry);
                        
                    }
                }
            });

            // announce client to the server
            var t = {
                "version": client_version,
                "uuid": uuid
            }
            eb.send("newclient", t);

            // tell the user whats what
            app_status("Registering Handlers");

            // allows the server to send special commands to THIS client
            eb.registerHandler(uuid, function(msg) {
                console.log("uuid message");
                console.log(msg);
                if (msg.action == "reload") {
                    console.log("server demands I reload");
                    location.reload();
                }
            });

            // stats handler is the flipclock
            eb.registerHandler("stats", stats_handler);

            // queue stats handler
            eb.registerHandler("queues", queues_handler);

            // handler for vpns
            eb.registerHandler("vpns", vpns_handler);

            // if this is a reconnect, call set_view_vpn to resubscribe, else just ignore it.
            if (vpn_data_active_topic != "default") {
                set_view_vpn(vpn_data_active_topic);
            }

        };

        eb.onclose = function () {
            app_status("Disconnected");
            clearInterval(reconnector);
            reconnector = setInterval(initialiseEventbus, 5000);
            var toggle = true;

            // added toggle to get 30 FPS instead of 60 FPS
            (function loop() {
                toggle = !toggle;
                if (toggle) {
                    requestAnimationFrame(loop);
                    return;
                }
                noise(ctx);
                requestAnimationFrame(loop);
            })();
        }
        
        // make flipclock smaller on mobile
        if (ismobile) {
            document.getElementById("flipclock").style.zoom = 0.5;
            document.getElementById("flipclock").style.MozTransition = "transform: scale(0.5)";
        }

    }


    initialiseEventbus();


});
             
</script>

</head>
<body>

<div class="navbar-fixed">
    <nav>
        <div class="nav-wrapper blue">
            <a href="#" id="app_title" class="hide-on-small-only brand-logo center">Solace Monitor</a>
            <ul id="nav-fixed" class="left blue">

                <li><a class='dropdown-button' href='#' data-activates='vpns'>Select VPN Dashboard<i class="waves-effect mdi-action-assessment right"></i></a></li>

                <!-- chart style options -->
                <ul id='vpns' class='dropdown-content z-depth-2'>
                    <li><a href="#!" class='waves-effect waves-teal' onclick=location.reload()>Overview</a></li>
                </ul>

            </ul>
        </div>
    </nav>
</div>

<div style="height: 100%; width: 100%">
    <div class="valign-wrapper center">

        <div class="row" style="width: 100%">
            <div class="valign center"><!--<h3 class="center-align">Solace Messages Since Go-Live</h3>-->
                <div id="flipclock" class="h1z1-clock"></div>
            </div>
            <div class="row">
                <div id="bigcharts" class="bigcharts col s12 l9 zchartContainer valign center"></div>
                <div id="charts" class="col s12 l3 zchartContainer valign center"></div>
            </div>
            <div class="row">
                <div id="smallcharts-1" class="col s12 l3 zchartContainer valign center"></div>
                <div id="smallcharts-2" class="col s12 l3 zchartContainer valign center"></div>
                <div id="smallcharts-3" class="col s12 l3 zchartContainer valign center"></div>
                <div id="smallcharts-4" class="col s12 l3 zchartContainer valign center"></div>
            </row>
        </div>
    </div>

    <!-- Modal Structure -->
    <div id="modal1" class="modal">

        <canvas id="canvas">
            <!-- <div class="modal-content">
                <h4>Connection Lost</h4>
                <p>Attempting to re-establish communication.</p>
            </div> -->

        </canvas>
    </div>


</div>

    <footer class="page-footer blue hide-on-small-only">
        <div class="footer-copyright blue">
            <div class="container blue">
                by Kegan Holtzhausen
                <a class="grey-text text-lighten-4 right" href="https://github.com/unixunion/solace-dashboards">Source</a>
            </div>
        </div>
    </footer>


<script type="text/javascript">
 
    // flipclock stuff
    var clock = $('.h1z1-clock').FlipClock(target_rate, {
        clockFace: 'Counter'
    });

    setTimeout(function() {
        setInterval(function() {
      
            if (current_rate < target_rate ) {
                current_rate = Math.ceil(current_rate + ((target_rate-current_rate)/refresh_rate));
            } else {
                current_rate = target_rate;
            }
      
      
            clock.setCounter(Math.ceil(current_rate/1000) + "K")
        }, refresh_rate);
    });


    // static noise
    var canvas = document.getElementById('canvas'),
    ctx = canvas.getContext('2d');
    ctx.globalCompositeOperation = "multiply";
    canvas.width = canvas.height = 256;

    var image = new Image();
    image.src = "/img/nosignal2.jpg";

    function resize() {
        canvas.style.width = $("#modal1").innerWidth() + 'px';
        canvas.style.height = $("#modal1").innerHeight() + 'px';
    }
    resize();
    window.onresize = resize;

    function noise(ctx) {

        var w = ctx.canvas.width,
            h = ctx.canvas.height,
            idata = ctx.createImageData(w, h),
            buffer32 = new Uint32Array(idata.data.buffer),
            len = buffer32.length,
            i = 0;

        for(; i < len;i++)
        if (Math.random() < 0.5) buffer32[i] = 0xff111111;

        ctx.putImageData(idata, 0, 0);
        ctx.font="28px Arial Black";
        ctx.fillStyle="#FFFFFF";
        ctx.textAlign = "center";
        ctx.fillText("Please Standby",128,164);
        ctx.globalCompositeOperation = "soft-light";
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);


    }


  
</script>



</body>
</html>